smoothBiomass <- function(biomass.ts) {
  # Fit Kalman filter to biomass data, extract fits to get estimate of true process
  smoothed <- fitted(StructTS(biomass.ts, type='level'))
  return(smoothed)
}

getSP <- function(spp.region.df) {
  # Calculate annual surplus production using smoothed biomass estimates
  first.diff <- diff(spp.region.df$smoothed)
  sp <- first.diff + spp.region.df$LANDINGS[1:(nrow(spp.region.df)-1)]
  return(c(sp, NA))
}

check.missing.years <- function(new.data.frame, yr.range) {  
  # Check if years are missing from biomass time series. Insert NAs for missing years.
  if(nrow(new.data.frame) < (diff(yr.range)+1)) { #If there is a missing year
    for(yr in yr.range[1]:yr.range[2]) {
      if(!(yr %in% new.data.frame$YEAR)) # find the missing year(s)
        new.data.frame <- rbind(new.data.frame, c(yr, rep(NA, ncol(new.data.frame)-1))) # add a row of NAs for it
    }
    new.data.frame <- new.data.frame[order(new.data.frame$YEAR),] # re-sort the data frame
  }
  return(new.data.frame)
}

select.predators <- function(species.names, biomass.df, state='BIOMASS') {
  # Create matrix of biomass time series for a compartment of an ecopath model; columns are species.
  these.species <- subset(biomass.df, SPECIES %in% species.names)
  wide.data.frame <- reshape(these.species[,c(state, 'YEAR', 'SPECIES')], v.names=state, idvar='YEAR', timevar='SPECIES', direction='wide')
  yr.range <- range(biomass.df$YEAR)
  all.years.df <- check.missing.years(wide.data.frame, yr.range)
  return.mat <- as.matrix(all.years.df[,-1]) # column 1 is YEAR
  colnames(return.mat) <- sort(species.names)
  rownames(return.mat) <- all.years.df$YEAR
  return(return.mat)
}

fill.pred.list <- function(species.names, biomass.df) {
  # Find species biomasses for a compartment of an ecopath model.
  # Replaces missing values with the mean. (Try interpolating instead?)
  # Returns matrix for compartment: one row per species
  selected.predators.temp <- select.predators(species.names, biomass.df)
  # Make sure years go in right order instead of NAs at the end.
  selected.predators <- selected.predators.temp[
    order(as.numeric(rownames(selected.predators.temp)), decreasing = FALSE),] %>% 
    array(dim=dim(selected.predators.temp), dimnames = dimnames(selected.predators.temp))
  rownames(selected.predators) <- sort(as.numeric(rownames(selected.predators)), decreasing = FALSE)
  filled.nas <- apply(selected.predators, 2, function(species) {
    new.species <- species
    measured.yrs <- which(!is.na(species))
    for(na in which(is.na(species))) {
     # for(na in which(is.na(species))[1:12]) {
      if(na==1) {
        new.species[na] <- species[min(measured.yrs)]
      } else if(na > max(measured.yrs)) {
        new.species[na] <- new.species[max(measured.yrs)]
      } else {
        # Calculate slope between last and next measured values
        last.value.ind <- max(measured.yrs[measured.yrs<na], na.rm = TRUE)
        next.value.ind <- min(measured.yrs[measured.yrs>na], na.rm = TRUE)
        slope.to.add <- diff(new.species[c(last.value.ind, next.value.ind)])/
          (next.value.ind - last.value.ind)
        # Add slope to last value in new.species, interpolated or measured
        new.species[na] <- new.species[na-1] + slope.to.add
      }
      measured.yrs <- c(measured.yrs, na)
    }
    if(sum(is.na(new.species))>0) print("na function didn't work!")
    # new.species[which(is.na(species))] <- mean(species, na.rm=T) # mean? linearly interpolate?
    return(new.species)})
  # sum.pred.biomass <- apply(filled.nas, 1, sum)
  return(filled.nas)
}

get.predation.index <- function(pred.list, prop.nat.mort) {
  # Calculate predation signal for a species using proportions of natural mortality from ecopath models
  # Turn wide data frame into long one
  pred.index.list <- list()
  for(group in 1:length(pred.list)) {
    group.name <- names(pred.list)[group]
    if(is.na(prop.nat.mort[group.name])) {
      print(paste('Name', group, 'in list does not match a name in the mortality matrix'))
      return()
    }
    wide.df <- data.frame(pred.list[[group]]*prop.nat.mort[group.name])
    wide.df$year <- as.numeric(rownames(wide.df))
    pred.index.list[[group]] <- melt(wide.df, id.vars='year', value.name='pred.signal', variable.name='species')
    pred.index.list[[group]]$species <- gsub('\\.', ' ', pred.index.list[[group]]$species)
    pred.index.list[[group]]$species <- gsub('NS', '(NS)', pred.index.list[[group]]$species)
  }
  names(pred.index.list) <- names(pred.list)
  return(pred.index.list)
}

get.nat.mort.matrix <- function(ncompartment, ecosystem) {
  # Read natural mortality matrix from .csv file generated by ecopath model
  filename <- paste('ecopath', ecosystem, 'Diet.csv', sep='/')
  char.mat <- matrix(scan(file=filename, what='raw', sep=','), nrow=ncompartment+1, byrow=T)
  numer.mat <- matrix(as.numeric(char.mat[(1:ncompartment)+1, (1:ncompartment)+1]), nrow=ncompartment, 
                         dimnames=list(prey=char.mat[1,(1:ncompartment)+1], pred=char.mat[1,(1:ncompartment)+1]))
  return(numer.mat)
}

read.group.info <- function(ecosystem) {
  # Reads in group info table from ecopath model in folder ecosystem
  read.csv(paste('ecopath', ecosystem, 'GroupInfo.csv', sep='/'), header=TRUE)
}

expand.group <- function(ROW, df) {
  # Function used in calculating contribution to natural mortality from each predator species
  # in ecopath model.
  ROW$QB / df$Biomass
}

combine.groups <- function(group.names, mort.nat, group.info) {
  # Combine diet information on adults/juveniles into one column (predator category) in 
  # natural mortality matrix.
  # Used when time series data are less detailed than ecopath model compartments.
  mort.sum <- 0
  for(grp in 1:length(group.names)) {
    mort.sum <- mort.sum + (group.info$Biomass[group.info$GroupName==group.names[grp]] * mort.nat[,group.names[grp]])
  }
  new.mort.nat <- mort.sum/sum(group.info$Biomass[group.info$GroupName %in% group.names])
  return(new.mort.nat)
}

get.mortality.props <- function(mort.nat.vecs, prey, region, group.info) {
  # Calculate proportion of mortality each predator group makes up for a prey species and put into data frame.
  # Handles one or multiple prey species, but must be in a single region.
  
  if(length(prey) > 1) {
    rownames(mort.nat.vecs) <- prey
    mort.props.wide <- data.frame(region, pred=colnames(mort.nat.vecs), t(mort.nat.vecs) * group.info$Biomass)
    mort.props <- melt(mort.props.wide, id.vars=c('region', 'pred'), value.name='mort', variable.name='prey')
    # The following line works because no cameo species names have a period in them. Checked 8/27/14.
    mort.props$prey <- gsub(pattern='.', replacement=' ', x=mort.props$prey, fixed=TRUE)
  } else {
    mort.props <- data.frame(region, pred=names(mort.nat.vecs), prey=prey,
                                  mort = mort.nat.vecs * group.info$Biomass)
  } 
  return(mort.props)  
}
  
get.predation.byspp <- function(cameo.prey, ecopath.prey, region, pred.list, mort.nat) {
  # Take result from get.predation.df (i.e., pred.list weighted by diets and consumption)
  # and turn into one long data frame.
  # Do this for any number of prey species. Returns one (long) data frame with predation time series for all
  # prey, separated out by predator group.
  
  byspp <- data.frame(year=integer(), species=character(), pred.signal=numeric(), prey.spp=character(),
                      region=character())
  for(spp in 1:length(cameo.prey)) {
    pred.index.list <- get.predation.index(pred.list, mort.nat[ecopath.prey[spp],])
    byspp.temp <- do.call('rbind', pred.index.list)
    byspp.temp$prey.spp <- cameo.prey[spp]
    byspp.temp$region <- region
    byspp <- rbind(byspp, byspp.temp)
  }
  return(byspp)
}

get.predation <- function(cameo.prey, ecopath.prey, region, pred.list, mort.nat, group.info) {
  # Get predation information for an ecosystem. Returns list of two data frames: 
  # [[1]] byspp: time series of predator field for each prey species of interest, separated out by predator
  #              group
  # [[2]] mort.props: proportion of natural mortality that each predator species makes up at the ecopath 
  #                   equilibrium, calculated for each prey species of interest
  
  if(length(cameo.prey) != length(ecopath.prey)) {
    print('Cameo and ecopath prey vectors of different lengths.')
    return()
  }
  
  byspp <- get.predation.byspp(cameo.prey, ecopath.prey, region, pred.list, mort.nat)
  mort.props <- get.mortality.props(mort.nat.vecs=mort.nat[ecopath.prey, 1:nrow(mort.nat)], # Want only square part of natural mortality matrix, not extra columns added
                                    prey=cameo.prey, region=region, group.info=group.info)
  return(list(byspp=byspp, mort.props=mort.props))
}
